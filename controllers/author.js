var authorService = require('../services/author');
var customErrorHandler = require('../custom_error_handler');

function authorController() {

    this.selectAuthor = function (id, res) {
        return new Promise((resolve, reject) => {
            resolve(authorService.selectAuthor(id, res)); // Calls service
        }).then((result) => {
            res.json(result); // Sends promise result to client 
        }).catch(err => {
            res.status(500).json({error: true, origin: {module: 'authorController', function: 'selectAuthor'}, data: {message: err.message}});
        })
    }

    this.insertAuthor = function (req, res) {
        authorService.insertAuthor(req, res);
    }

    this.updateAuthor = function (req, res) {
        authorService.updateAuthor(req, res);
    }

    // ERROR HANDLING PRACTICE
    this.deleteAuthor = function (id, res) {
        try {
            //throw ("I've fired an error!") // Creates a simple string
            //throw new Error("Something goes wrong!"); // Uses the Error class
            throw new customErrorHandler("Something goes wrong!", "authorController.deleteAuthor"); // Uses the custom error object
        } catch (error) {
            //console.log(error);
            //console.log(error.name);
            //console.log(error.message);
            //console.log(error.where);
            //console.log(error.stack);
            //console.log("It's generated by my custom error handler? "+(error instanceof customErrorHandler));
            if (error instanceof customErrorHandler){
                console.log("The error has been generated by custom error handler");
                console.log("At: "+error.where);
                console.log(error.stack);
            }
            else {
                console.log('Something fired a no handled error');
                throw error;
            }
        } finally { // With finally statement the code will be executed in spite of what happen in try or catch statement
            authorService.deleteAuthor(id, res);
        }
    }

    /*this.deleteAuthor = function (id, res) {
        authorService.deleteAuthor(id, res);    
    }*/

    this.selectAuthorBooks = function (id, res) {
        authorService.selectAuthorBooks(id, res);
    }

    process.on("uncaughtException", function (error) {
        console.log("The exception was caught!")
    })
}

module.exports = new authorController();